import { ShaderGraph } from './shader_graph.js';
import { ShaderNode, ShaderDataType, ShaderPort, MathOp, TrigOp, LightModel } from './shader_node.js';

// ============================================================
// WGSL ShaderCompiler for WebGPU (TypeScript)
// ============================================================

function varName(nodeId: number, port: number): string {
    return `n${nodeId}_p${port}`;
}

function wgslTypeName(dt: ShaderDataType): string {
    switch (dt) {
        case ShaderDataType.Float: return 'f32';
        case ShaderDataType.Vec2: return 'vec2<f32>';
        case ShaderDataType.Vec3: return 'vec3<f32>';
        case ShaderDataType.Vec4: return 'vec4<f32>';
        case ShaderDataType.Mat3: return 'mat3x3<f32>';
        case ShaderDataType.Mat4: return 'mat4x4<f32>';
        case ShaderDataType.Bool: return 'bool';
        default: return 'f32';
    }
}

function defaultValueWGSL(port: ShaderPort): string {
    const d = port.defaultValue.data;
    if (typeof d === 'number') return d.toString();
    if (typeof d === 'boolean') return d ? 'true' : 'false';
    if (Array.isArray(d)) {
        if (d.length === 2) return `vec2<f32>(${d[0]}, ${d[1]})`;
        if (d.length === 3) return `vec3<f32>(${d[0]}, ${d[1]}, ${d[2]})`;
        if (d.length === 4) return `vec4<f32>(${d[0]}, ${d[1]}, ${d[2]}, ${d[3]})`;
    }
    return '0.0';
}

function typeCastWGSL(expr: string, from: ShaderDataType, to: ShaderDataType): string {
    if (from === to) return expr;
    if (from === ShaderDataType.Float) {
        if (to === ShaderDataType.Vec2) return `vec2<f32>(${expr})`;
        if (to === ShaderDataType.Vec3) return `vec3<f32>(${expr})`;
        if (to === ShaderDataType.Vec4) return `vec4<f32>(vec3<f32>(${expr}), 1.0)`;
    }
    if (from === ShaderDataType.Vec3 && to === ShaderDataType.Vec4) return `vec4<f32>(${expr}, 1.0)`;
    if (from === ShaderDataType.Vec4 && to === ShaderDataType.Vec3) return `${expr}.xyz`;
    return expr;
}

export class ShaderCompiler {
    generateVertex(): string {
        let s = '// Generated by Ergo ShaderCompiler (WGSL)\n\n';
        s += 'struct GlobalUBO {\n    view: mat4x4<f32>,\n    projection: mat4x4<f32>,\n';
        s += '    time: f32,\n    camera_pos: vec3<f32>,\n};\n\n';
        s += 'struct ObjectUBO {\n    model: mat4x4<f32>,\n    normal_matrix: mat4x4<f32>,\n};\n\n';
        s += '@group(0) @binding(0) var<uniform> global: GlobalUBO;\n';
        s += '@group(1) @binding(0) var<uniform> object: ObjectUBO;\n\n';
        s += 'struct VertexInput {\n    @location(0) position: vec3<f32>,\n';
        s += '    @location(1) normal: vec3<f32>,\n    @location(2) uv: vec2<f32>,\n};\n\n';
        s += 'struct VertexOutput {\n    @builtin(position) clip_pos: vec4<f32>,\n';
        s += '    @location(0) world_pos: vec3<f32>,\n    @location(1) world_normal: vec3<f32>,\n';
        s += '    @location(2) uv: vec2<f32>,\n    @location(3) view_dir: vec3<f32>,\n};\n\n';
        s += '@vertex\nfn vs_main(in: VertexInput) -> VertexOutput {\n';
        s += '    var out: VertexOutput;\n';
        s += '    let world_pos = object.model * vec4<f32>(in.position, 1.0);\n';
        s += '    out.world_pos = world_pos.xyz;\n';
        s += '    out.world_normal = normalize((object.normal_matrix * vec4<f32>(in.normal, 0.0)).xyz);\n';
        s += '    out.uv = in.uv;\n';
        s += '    out.view_dir = normalize(global.camera_pos - world_pos.xyz);\n';
        s += '    out.clip_pos = global.projection * global.view * world_pos;\n';
        s += '    return out;\n}\n';
        return s;
    }

    generateFragment(graph: ShaderGraph): string {
        let s = '// Generated by Ergo ShaderCompiler (WGSL)\n\n';

        // Uniforms
        s += 'struct GlobalUBO {\n    view: mat4x4<f32>,\n    projection: mat4x4<f32>,\n';
        s += '    time: f32,\n    camera_pos: vec3<f32>,\n};\n\n';
        s += 'struct LightUBO {\n    light_dir: vec3<f32>,\n    light_color: vec3<f32>,\n';
        s += '    light_intensity: f32,\n    ambient_color: vec3<f32>,\n};\n\n';
        s += '@group(0) @binding(0) var<uniform> global: GlobalUBO;\n';
        s += '@group(0) @binding(1) var<uniform> light: LightUBO;\n\n';

        // Fragment function
        s += '@fragment\nfn fs_main(\n';
        s += '    @location(0) v_world_pos: vec3<f32>,\n';
        s += '    @location(1) v_world_normal: vec3<f32>,\n';
        s += '    @location(2) v_uv: vec2<f32>,\n';
        s += '    @location(3) v_view_dir: vec3<f32>\n';
        s += ') -> @location(0) vec4<f32> {\n';

        const outputId = graph.findOutputNode();
        if (outputId === 0) {
            s += '    return vec4<f32>(1.0, 0.0, 1.0, 1.0);\n}\n';
            return s;
        }

        const emitted = new Set<number>();
        let body = '';

        const out = graph.getNode(outputId)!;
        let albedo = 'vec3<f32>(0.5, 0.5, 0.5)';
        let alpha = '1.0';

        for (let i = 0; i < out.inputs.length; i++) {
            const conn = graph.findInputConnection(outputId, i);
            if (!conn) continue;
            const srcNode = graph.getNode(conn.sourceNode);
            if (!srcNode) continue;

            const [expr, bodyAdd] = this.resolveNode(graph, conn.sourceNode, conn.sourcePort, emitted);
            body += bodyAdd;
            const srcType = srcNode.outputs[conn.sourcePort].dataType;
            const dstType = out.inputs[i].dataType;
            const cast = typeCastWGSL(expr, srcType, dstType);

            if (out.inputs[i].name === 'Albedo') albedo = cast;
            else if (out.inputs[i].name === 'Alpha') alpha = cast;
        }

        s += body;
        s += `    return vec4<f32>(${albedo}, ${alpha});\n}\n`;
        return s;
    }

    private resolveNode(
        graph: ShaderGraph, nodeId: number, portIndex: number, emitted: Set<number>
    ): [string, string] {
        const node = graph.getNode(nodeId);
        if (!node) return ['0.0', ''];

        const vn = varName(nodeId, portIndex);
        const key = (nodeId << 16) | portIndex;
        if (emitted.has(key)) return [vn, ''];

        let body = '';

        const resolveInput = (idx: number): [string, string] => {
            const conn = graph.findInputConnection(nodeId, idx);
            if (conn) {
                const srcNode = graph.getNode(conn.sourceNode);
                if (!srcNode) return ['0.0', ''];
                const [expr, b] = this.resolveNode(graph, conn.sourceNode, conn.sourcePort, emitted);
                const srcType = srcNode.outputs[conn.sourcePort].dataType;
                const dstType = node.inputs[idx].dataType;
                return [typeCastWGSL(expr, srcType, dstType), b];
            }
            if (idx < node.inputs.length) return [defaultValueWGSL(node.inputs[idx]), ''];
            return ['0.0', ''];
        };

        let expr = '';
        let typeStr = '';
        const data = node.data;

        switch (data.type) {
            case 'PropertyFloat':
                expr = `material.${data.uniformName}`;
                typeStr = 'f32';
                break;
            case 'PropertyVec4': {
                const base = `material.${data.uniformName}`;
                const types = ['vec4<f32>', 'vec3<f32>', 'f32', 'f32', 'f32', 'f32'];
                const suffix = ['', '.xyz', '.x', '.y', '.z', '.w'];
                typeStr = types[portIndex] ?? 'vec4<f32>';
                expr = base + (suffix[portIndex] ?? '');
                break;
            }
            case 'Math': {
                typeStr = wgslTypeName(node.outputs[portIndex].dataType);
                const [a, ba] = resolveInput(0);
                body += ba;
                const [b, bb] = resolveInput(1);
                body += bb;
                switch (data.op) {
                    case MathOp.Add: expr = `(${a} + ${b})`; break;
                    case MathOp.Subtract: expr = `(${a} - ${b})`; break;
                    case MathOp.Multiply: expr = `(${a} * ${b})`; break;
                    case MathOp.Divide: expr = `(${a} / max(${b}, 0.0001))`; break;
                    case MathOp.Normalize: expr = `normalize(${a})`; break;
                    case MathOp.Length: expr = `length(${a})`; break;
                    case MathOp.Dot: expr = `dot(${a}, ${b})`; break;
                    case MathOp.Cross: expr = `cross(${a}, ${b})`; break;
                    case MathOp.Abs: expr = `abs(${a})`; break;
                    case MathOp.Negate: expr = `(-${a})`; break;
                    case MathOp.Fract: expr = `fract(${a})`; break;
                    case MathOp.Floor: expr = `floor(${a})`; break;
                    case MathOp.Ceil: expr = `ceil(${a})`; break;
                    case MathOp.Min: expr = `min(${a}, ${b})`; break;
                    case MathOp.Max: expr = `max(${a}, ${b})`; break;
                    case MathOp.SquareRoot: expr = `sqrt(max(${a}, 0.0))`; break;
                    case MathOp.Power: expr = `pow(${a}, ${b})`; break;
                    case MathOp.Lerp: {
                        const [t, bt] = resolveInput(2); body += bt;
                        expr = `mix(${a}, ${b}, ${t})`; break;
                    }
                    case MathOp.Clamp: {
                        const [mn, bmn] = resolveInput(1); body += bmn;
                        const [mx, bmx] = resolveInput(2); body += bmx;
                        expr = `clamp(${a}, ${mn}, ${mx})`; break;
                    }
                    case MathOp.Step: expr = `step(${a}, ${b})`; break;
                    case MathOp.SmoothStep: {
                        const [e1, be1] = resolveInput(1); body += be1;
                        const [x, bx] = resolveInput(2); body += bx;
                        expr = `smoothstep(${a}, ${e1}, ${x})`; break;
                    }
                    default: expr = '0.0'; break;
                }
                break;
            }
            case 'Trig': {
                typeStr = 'f32';
                const [a, ba] = resolveInput(0);
                body += ba;
                switch (data.op) {
                    case TrigOp.Sin: expr = `sin(${a})`; break;
                    case TrigOp.Cos: expr = `cos(${a})`; break;
                    case TrigOp.Tan: expr = `tan(${a})`; break;
                    case TrigOp.Asin: expr = `asin(clamp(${a}, -1.0, 1.0))`; break;
                    case TrigOp.Acos: expr = `acos(clamp(${a}, -1.0, 1.0))`; break;
                    case TrigOp.Atan: expr = `atan(${a})`; break;
                    case TrigOp.Atan2: {
                        const [b, bb] = resolveInput(1); body += bb;
                        expr = `atan2(${a}, ${b})`; break;
                    }
                    default: expr = `sin(${a})`; break;
                }
                break;
            }
            case 'TextureSample': {
                const [uv, buv] = resolveInput(0);
                body += buv;
                const baseVar = varName(nodeId, 99);
                body += `    let ${baseVar} = textureSample(t_${data.textureUniform}, s_${data.textureUniform}, ${uv});\n`;
                const types = ['vec4<f32>', 'vec3<f32>', 'f32', 'f32', 'f32', 'f32'];
                const suffix = ['', '.xyz', '.x', '.y', '.z', '.w'];
                typeStr = types[portIndex] ?? 'vec4<f32>';
                expr = baseVar + (suffix[portIndex] ?? '');
                break;
            }
            case 'Time':
                typeStr = 'f32';
                if (portIndex === 0) expr = `(global.time * ${data.speed})`;
                else if (portIndex === 1) expr = `sin(global.time * ${data.speed})`;
                else expr = `cos(global.time * ${data.speed})`;
                break;
            case 'Normal':
                typeStr = 'vec3<f32>';
                expr = 'v_world_normal';
                break;
            case 'Position':
                typeStr = 'vec3<f32>';
                expr = 'v_world_pos';
                break;
            case 'ViewDirection':
                typeStr = 'vec3<f32>';
                expr = 'v_view_dir';
                break;
            case 'Lighting': {
                const [normal, bn] = resolveInput(0); body += bn;
                const [albedo, ba] = resolveInput(1); body += ba;
                body += `    let ${vn}_ndotl = max(dot(${normal}, -light.light_dir), 0.0);\n`;
                if (portIndex === 0) {
                    expr = `(${albedo} * light.light_color * light.light_intensity * ${vn}_ndotl + ${albedo} * light.ambient_color)`;
                    typeStr = 'vec3<f32>';
                } else {
                    expr = `${vn}_ndotl`;
                    typeStr = 'f32';
                }
                break;
            }
            case 'Fresnel': {
                const [normal, bn] = resolveInput(0); body += bn;
                const [view, bv] = resolveInput(1); body += bv;
                const [power, bp] = resolveInput(2); body += bp;
                expr = `pow(1.0 - max(dot(${normal}, ${view}), 0.0), ${power})`;
                typeStr = 'f32';
                break;
            }
            case 'Constant':
                typeStr = wgslTypeName(data.outputType);
                if (typeof data.value === 'number') expr = data.value.toString();
                else if (Array.isArray(data.value)) {
                    if (data.value.length === 3) expr = `vec3<f32>(${data.value.join(', ')})`;
                    else if (data.value.length === 4) expr = `vec4<f32>(${data.value.join(', ')})`;
                    else expr = data.value.toString();
                }
                else expr = '0.0';
                break;
            case 'Blend': {
                typeStr = 'vec3<f32>';
                const [base, bbase] = resolveInput(0); body += bbase;
                const [blend, bblend] = resolveInput(1); body += bblend;
                const [opacity, bop] = resolveInput(2); body += bop;
                expr = `mix(${base}, ${blend}, ${opacity})`;
                break;
            }
            case 'Custom':
                typeStr = wgslTypeName(node.outputs[portIndex].dataType);
                expr = data.wgslCode;
                for (let i = 0; i < node.inputs.length; i++) {
                    const [inp, bi] = resolveInput(i);
                    body += bi;
                    expr = expr.replaceAll(`\${input_${i}}`, inp);
                }
                break;
            case 'Output':
                return ['', ''];
            default:
                expr = '0.0';
                typeStr = 'f32';
                break;
        }

        if (expr && typeStr) {
            body += `    let ${vn}: ${typeStr} = ${expr};\n`;
            emitted.add(key);
        }

        return [vn, body];
    }
}
